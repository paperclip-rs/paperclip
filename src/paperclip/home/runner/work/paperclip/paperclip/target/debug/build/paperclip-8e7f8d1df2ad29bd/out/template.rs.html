<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/work/paperclip/paperclip/target/debug/build/paperclip-8e7f8d1df2ad29bd/out/template.rs`."><title>template.rs - source</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../../../../../../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../../../../../../../../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../../../../../../../../../../../" data-static-root-path="../../../../../../../../../../../../static.files/" data-current-crate="paperclip" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0-nightly (4bc39f028 2024-06-26)" data-channel="nightly" data-search-js="search-0fe7219eb170c82e.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../../../../../../../../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../../../../../../../../../../../../static.files/src-script-e66d777a5a92e9b2.js"></script><script defer src="../../../../../../../../../../../../src-files.js"></script><script defer src="../../../../../../../../../../../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../../../../../../../../../../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../../../../../../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../../../../../../../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title"><h2>Files</h2></div></nav><div class="sidebar-resizer"></div><main><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="example-wrap"><div data-nosnippet><pre class="src-line-numbers"><a href="#1" id="1">1</a>
<a href="#2" id="2">2</a>
<a href="#3" id="3">3</a>
<a href="#4" id="4">4</a>
<a href="#5" id="5">5</a>
<a href="#6" id="6">6</a>
<a href="#7" id="7">7</a>
<a href="#8" id="8">8</a>
<a href="#9" id="9">9</a>
<a href="#10" id="10">10</a>
<a href="#11" id="11">11</a>
<a href="#12" id="12">12</a>
<a href="#13" id="13">13</a>
<a href="#14" id="14">14</a>
<a href="#15" id="15">15</a>
<a href="#16" id="16">16</a>
<a href="#17" id="17">17</a>
<a href="#18" id="18">18</a>
<a href="#19" id="19">19</a>
<a href="#20" id="20">20</a>
<a href="#21" id="21">21</a>
<a href="#22" id="22">22</a>
<a href="#23" id="23">23</a>
<a href="#24" id="24">24</a>
<a href="#25" id="25">25</a>
<a href="#26" id="26">26</a>
<a href="#27" id="27">27</a>
<a href="#28" id="28">28</a>
<a href="#29" id="29">29</a>
<a href="#30" id="30">30</a>
<a href="#31" id="31">31</a>
<a href="#32" id="32">32</a>
<a href="#33" id="33">33</a>
<a href="#34" id="34">34</a>
<a href="#35" id="35">35</a>
<a href="#36" id="36">36</a>
<a href="#37" id="37">37</a>
<a href="#38" id="38">38</a>
<a href="#39" id="39">39</a>
<a href="#40" id="40">40</a>
<a href="#41" id="41">41</a>
<a href="#42" id="42">42</a>
<a href="#43" id="43">43</a>
</pre></div><pre class="rust"><code>
<span class="attr">#[cfg(feature = <span class="string">"codegen"</span>)]
</span><span class="kw">mod </span>template {
    <span class="kw">use </span>tinytemplate::TinyTemplate;

    <span class="attr">#[derive(Debug, Copy, Clone)]
    #[allow(dead_code, non_camel_case_types)]
    </span><span class="kw">pub enum </span>Template {
        CARGO_MANIFEST,
        CLIENT_MOD,
        CLAP_YAML,
        CLI_MAIN,
        UTIL_MOD,
        CLI_UTIL,
    }
    <span class="kw">pub const </span>CARGO_MANIFEST: <span class="kw-2">&amp;</span>str = <span class="string">"[package]\nname = { name | unescaped }\nversion = { version | unescaped }\nauthors = { authors | unescaped }\nedition = \"2018\"\n{{ if is_cli }}\n[[bin]]\nname = { name | unescaped }\npath = \"main.rs\"\n{{ else }}\n[lib]\npath = \"lib.rs\"\n{{ endif }}\n[dependencies]\nasync-trait = \"0.1\"\nbytes = \"0.5\"\nthiserror = \"1.0\"\nfutures = \"0.3\"\nhttp = \"0.2\"\nlazy_static = \"1.4\"\nlog = \"0.4\"\nmime = \\{ git = \"https://github.com/hyperium/mime\" }\nmime_guess = \"2.0\"\nserde = \\{ version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\nserde_yaml = \"0.8\"\ntokio-util = \\{ version = \"0.4\", features = [\"codec\"] }\nurl = \"2.1\"\n{{ if is_cli }}\nanyhow = \"1.0\"\nclap = \\{ version = \"2.33\", features = [\"yaml\"] }\nenv_logger = \"0.7\"\nhumantime = \"2.0\"\nopenssl = \\{ version = \"0.10\", features = [\"vendored\"] }\ntokio = \\{ version = \"0.3\", features = [\"fs\", \"io-util\", \"io-std\", \"macros\", \"rt-multi-thread\"] }\nreqwest = \\{ version = \"0.10\", features = [\"stream\", \"json\", \"native-tls\"] }\n{{ else }}\ntokio = \\{ version = \"0.3\", features = [\"fs\", \"io-util\"] }\nreqwest = \\{ version = \"0.10\", features = [\"stream\", \"json\"] }\n{{ endif }}\n{{ if not no_root -}}\n[workspace]\n{{- endif }}\n"</span>;

    <span class="kw">pub const </span>CLIENT_MOD: <span class="kw-2">&amp;</span>str = <span class="string">"\npub mod client \\{\n    use futures::Stream;\n\n\n    use std::borrow::Cow;\n    use std::fmt::Debug;\n    use std::path::Path;\n\n    /// Common API errors.\n    #[derive(Debug, thiserror::Error)]\n    pub enum ApiError&lt;R: Debug + Send + 'static&gt; \\{\n        #[error(\"API request failed for path: \\{} (code: \\{})\", _0, _1)]\n        Failure(String, http::status::StatusCode, R),\n        #[error(\"Unsupported media type in response: \\{}\", _0)]\n        UnsupportedMediaType(String, R),\n        #[error(\"An error has occurred while performing the API request: \\{}\", _0)]\n        Reqwest(reqwest::Error),\n        #[error(\"I/O error: \\{}\", _0)]\n        Io(std::io::Error),\n        {{- for coder in media_coders }}\n        #[error(\"Error en/decoding \\\"{coder.range | unescaped}\\\" data: \\{}\", _0)]\n        {coder.error_variant | unescaped}({coder.error_ty_path | unescaped}),\n        {{- endfor }}\n    }\n\n    /// Form object for building multipart request body.\n    pub trait Form: Sized \\{\n        /// Creates a new builder.\n        fn new() -&gt; Self;\n\n        /// Adds the given key and value as text.\n        fn text&lt;T, U&gt;(self, key: T, value: U) -&gt; Self\n            where T: Into&lt;Cow&lt;'static, str&gt;&gt;,\n                  U: Into&lt;Cow&lt;'static, str&gt;&gt;;\n\n        /// Adds the file from the given path for streaming.\n        fn file&lt;K&gt;(self, key: K, path: &amp;Path) -&gt; std::io::Result&lt;Self&gt;\n            where K: Into&lt;Cow&lt;'static, str&gt;&gt;;\n    }\n\n    /// HTTP Request.\n    pub trait Request \\{\n        type Form: Form;\n\n        /// Sets the header with the given key and value.\n        fn header(self, name: &amp;'static str, value: &amp;str) -&gt; Self;\n\n        /// Sets body using the given vector of bytes.\n        ///\n        /// **NOTE:** Appropriate `Content-Type` header must be set\n        /// after calling this method.\n        fn body_bytes(self, body: Vec&lt;u8&gt;) -&gt; Self;\n\n        /// Sets JSON body based on the given value.\n        fn json&lt;T: serde::Serialize&gt;(self, value: &amp;T) -&gt; Self;\n\n        /// Sets `multipart/form-data` body using the given form.\n        fn multipart_form_data(self, form: Self::Form) -&gt; Self;\n\n        /// Sets/adds query parameters based on the given value.\n        ///\n        /// **NOTE:** This method must be called only once. It's unspecified\n        /// as to whether this appends/replaces query parameters.\n        fn query&lt;T: serde::Serialize&gt;(self, params: &amp;T) -&gt; Self;\n    }\n\n    impl Form for reqwest::multipart::Form \\{\n        fn new() -&gt; Self \\{\n            reqwest::multipart::Form::new()\n        }\n\n        fn text&lt;T, U&gt;(self, key: T, value: U) -&gt; Self\n            where T: Into&lt;Cow&lt;'static, str&gt;&gt;,\n                  U: Into&lt;Cow&lt;'static, str&gt;&gt;\n        \\{\n            reqwest::multipart::Form::text(self, key, value)\n        }\n\n        fn file&lt;K&gt;(self, key: K, path: &amp;Path) -&gt; std::io::Result&lt;Self&gt;\n            where K: Into&lt;Cow&lt;'static, str&gt;&gt;\n        \\{\n            use reqwest::multipart::\\{Form, Part};\n            use tokio_util::codec::\\{BytesCodec, FramedRead};\n\n            let fd = std::fs::File::open(path)?;\n            let reader = tokio::fs::File::from_std(fd);\n            let bytes_stream = FramedRead::new(reader, BytesCodec::new());\n            let part = Part::stream(reqwest::Body::wrap_stream(bytes_stream));\n            Ok(Form::part(self, key, part))\n        }\n    }\n\n    impl Request for reqwest::RequestBuilder \\{\n        type Form = reqwest::multipart::Form;\n\n        fn header(self, name: &amp;'static str, value: &amp;str) -&gt; Self \\{\n            reqwest::RequestBuilder::header(self, name, value)\n        }\n\n        fn multipart_form_data(self, form: Self::Form) -&gt; Self \\{\n            self.multipart(form)\n        }\n\n        fn body_bytes(self, body: Vec&lt;u8&gt;) -&gt; Self \\{\n            self.body(body)\n        }\n\n        fn json&lt;T: serde::Serialize&gt;(self, value: &amp;T) -&gt; Self \\{\n            &lt;reqwest::RequestBuilder&gt;::json(self, value)\n        }\n\n        fn query&lt;T: serde::Serialize&gt;(self, params: &amp;T) -&gt; Self \\{\n            reqwest::RequestBuilder::query(self, params)\n        }\n    }\n\n    /// HTTP Response.\n    #[async_trait::async_trait]\n    pub trait Response: Debug + Send + Sized \\{\n        type Bytes: AsRef&lt;[u8]&gt;;\n        type Error;\n\n        /// Gets the value for the given header name, if any.\n        fn header(&amp;self, name: &amp;'static str) -&gt; Option&lt;&amp;str&gt;;\n\n        /// Takes all headers from the response.\n        fn take_headers(&amp;mut self) -&gt; http::header::HeaderMap;\n\n        /// Status code for this response.\n        fn status(&amp;self) -&gt; http::status::StatusCode;\n\n        /// Media type for this response body (if any).\n        fn media_type(&amp;self) -&gt; Option&lt;mime::MediaType&gt;;\n\n        /// Response body as a stream.\n        fn stream(self) -&gt; Box&lt;dyn Stream&lt;Item=Result&lt;Self::Bytes, Self::Error&gt;&gt; + Unpin&gt;;\n\n        /// Vector of bytes from the response body.\n        async fn body_bytes(self) -&gt; Result&lt;Self::Bytes, ApiError&lt;Self&gt;&gt;;\n    }\n\n    #[async_trait::async_trait]\n    impl Response for reqwest::Response \\{\n        type Bytes = bytes::Bytes;\n        type Error = reqwest::Error;\n\n        fn header(&amp;self, name: &amp;'static str) -&gt; Option&lt;&amp;str&gt; \\{\n            self.headers().get(name).and_then(|v| v.to_str().ok())\n        }\n\n        fn take_headers(&amp;mut self) -&gt; http::header::HeaderMap \\{\n            std::mem::replace(self.headers_mut(), http::header::HeaderMap::new())\n        }\n\n        fn status(&amp;self) -&gt; http::status::StatusCode \\{\n            reqwest::Response::status(self)\n        }\n\n        fn media_type(&amp;self) -&gt; Option&lt;mime::MediaType&gt; \\{\n            self.header(http::header::CONTENT_TYPE.as_str())\n                .and_then(|v| v.parse().ok())\n        }\n\n        fn stream(self) -&gt; Box&lt;dyn Stream&lt;Item=Result&lt;Self::Bytes, Self::Error&gt;&gt; + Unpin&gt; \\{\n            Box::new(self.bytes_stream()) as Box&lt;_&gt;\n        }\n\n        async fn body_bytes(self) -&gt; Result&lt;Self::Bytes, ApiError&lt;Self&gt;&gt; \\{\n            Ok(self.bytes().await.map_err(ApiError::Reqwest)?)\n        }\n    }\n\n    /// Represents an API client.\n    #[async_trait::async_trait]\n    pub trait ApiClient \\{\n        type Request: Request + Send;\n        type Response: Response;\n\n        /// Consumes a method and a relative path and produces a request builder for a single API call.\n        fn request_builder(&amp;self, method: http::Method, rel_path: &amp;str) -&gt; Self::Request;\n\n        /// Performs the HTTP request using the given `Request` object\n        /// and returns a `Response` future.\n        async fn make_request(&amp;self, req: Self::Request) -&gt; Result&lt;Self::Response, ApiError&lt;Self::Response&gt;&gt;;\n    }\n\n    #[async_trait::async_trait]\n    impl ApiClient for reqwest::Client \\{\n        type Request = reqwest::RequestBuilder;\n        type Response = reqwest::Response;\n\n        fn request_builder(&amp;self, method: http::Method, rel_path: &amp;str) -&gt; Self::Request \\{\n            let mut u = String::from(\"{base_url | unescaped}\");\n            u.push_str(rel_path.trim_start_matches('/'));\n            self.request(method, &amp;u)\n        }\n\n        async fn make_request(&amp;self, req: Self::Request) -&gt; Result&lt;Self::Response, ApiError&lt;Self::Response&gt;&gt; \\{\n            let req = req.build().map_err(ApiError::Reqwest)?;\n            let resp = self.execute(req).await.map_err(ApiError::Reqwest)?;\n            Ok(resp)\n        }\n    }\n\n    /// A trait for indicating that the implementor can send an API call.\n    #[async_trait::async_trait]\n    pub trait Sendable&lt;Client&gt;\n    where\n        Client: ApiClient + Sync + 'static,\n        Self: Sized\n    \\{\n        /// The output object from this API request.\n        type Output: serde::de::DeserializeOwned;\n\n        /// HTTP method used by this call.\n        const METHOD: http::Method;\n\n        /// Relative URL for this API call formatted appropriately with parameter values.\n        ///\n        /// **NOTE:** This URL **must** begin with `/`.\n        fn rel_path(&amp;self) -&gt; std::borrow::Cow&lt;'static, str&gt;;\n\n        /// Modifier for this object. Builders override this method if they\n        /// wish to add query parameters, set body, etc.\n        fn modify(&amp;self, req: Client::Request) -&gt; Result&lt;Client::Request, ApiError&lt;Client::Response&gt;&gt; \\{\n            Ok(req)\n        }\n\n        /// Sends the request and returns a future for the response object.\n        async fn send(&amp;self, client: &amp;Client) -&gt; Result&lt;ResponseWrapper&lt;Self::Output, Self&gt;, ApiError&lt;Client::Response&gt;&gt; \\{\n            let resp = self.send_raw(client).await?;\n            let media = resp.media_type();\n            if let Some(ty) = media \\{\n                if media_types::M_0.matches(&amp;ty) \\{\n                    return ResponseWrapper::wrap(resp, |r| async \\{\n                        let bytes = r.body_bytes().await?;\n                        serde_json::from_reader(bytes.as_ref()).map_err(ApiError::from)\n                    }).await\n                }\n                else if media_types::M_1.matches(&amp;ty) \\{\n                    return ResponseWrapper::wrap(resp, |r| async \\{\n                        let bytes = r.body_bytes().await?;\n                        serde_yaml::from_reader(bytes.as_ref()).map_err(ApiError::from)\n                    }).await\n                }\n            }\n\n            let ty = resp.header(http::header::CONTENT_TYPE.as_str())\n                .map(|v| String::from_utf8_lossy(v.as_bytes()).into_owned())\n                .unwrap_or_default();\n            Err(ApiError::UnsupportedMediaType(ty, resp))\n        }\n\n        /// Convenience method for returning a raw response after sending a request.\n        async fn send_raw(&amp;self, client: &amp;Client) -&gt; Result&lt;Client::Response, ApiError&lt;Client::Response&gt;&gt; \\{\n            let rel_path = self.rel_path();\n            let req = self.modify(client.request_builder(Self::METHOD, &amp;rel_path))?;\n            let resp = client.make_request(req).await?;\n            if resp.status().is_success() \\{\n                Ok(resp)\n            } else \\{\n                Err(ApiError::Failure(rel_path.into_owned(), resp.status(), resp))\n            }\n        }\n    }\n\n    /// Wrapper containing response-related information.\n    pub struct ResponseWrapper&lt;T, B&gt; \\{\n        /// Response object\n        pub object: T,\n        /// Response headers\n        pub headers: http::HeaderMap,\n        /// Response status code\n        pub status: http::status::StatusCode,\n        _builder: core::marker::PhantomData&lt;B&gt;,\n    }\n\n    impl&lt;T, B&gt; ResponseWrapper&lt;T, B&gt; \\{\n        pub(crate) async fn wrap&lt;F, R&gt;(mut resp: R, f: impl FnOnce(R) -&gt; F) -&gt; Result&lt;Self, ApiError&lt;R&gt;&gt;\n            where F: std::future::Future&lt;Output=Result&lt;T, ApiError&lt;R&gt;&gt;&gt;,\n                  R: Response + 'static\n        \\{\n            let status = resp.status();\n            let headers = resp.take_headers();\n            Ok(ResponseWrapper \\{\n                object: f(resp).await?,\n                headers,\n                status,\n                _builder: core::marker::PhantomData,\n            })\n        }\n    }\n\n    impl&lt;'de, T, B&gt; serde::de::Deserialize&lt;'de&gt; for ResponseWrapper&lt;T, B&gt; \\{\n        fn deserialize&lt;D&gt;(_: D) -&gt; Result&lt;Self, D::Error&gt;\n        where\n            D: serde::de::Deserializer&lt;'de&gt;\n        \\{\n            unimplemented!(\"ResponseWrapper is not supposed to be deserialized.\");\n        }\n    }\n\n    impl&lt;T, B&gt; std::ops::Deref for ResponseWrapper&lt;T, B&gt; \\{\n        type Target = T;\n\n        fn deref(&amp;self) -&gt; &amp;Self::Target \\{\n            &amp;self.object\n        }\n    }\n\n    impl&lt;T, B&gt; std::ops::DerefMut for ResponseWrapper&lt;T, B&gt; \\{\n        fn deref_mut(&amp;mut self) -&gt; &amp;mut &lt;Self as std::ops::Deref&gt;::Target \\{\n            &amp;mut self.object\n        }\n    }\n\n    pub mod media_types \\{\n        use lazy_static::lazy_static;\n\n        lazy_static! \\{\n            {{- for coder in media_coders }}\n            pub static ref M_{ @index }: mime::MediaRange =\n                mime::MediaRange::parse(\"{coder.range | unescaped}\").expect(\"cannot parse \\\"{coder.range | unescaped}\\\" as media range\");\n            {{- endfor }}\n        }\n    }\n\n    impl&lt;R: Response + 'static&gt; From&lt;std::io::Error&gt; for ApiError&lt;R&gt; \\{\n        fn from(e: std::io::Error) -&gt; Self \\{\n            ApiError::Io(e)\n        }\n    }\n    {{- for coder in media_coders }}\n\n    impl&lt;R: Response + 'static&gt; From&lt;{coder.error_ty_path | unescaped}&gt; for ApiError&lt;R&gt; \\{\n        fn from(e: {coder.error_ty_path | unescaped}) -&gt; Self \\{\n            ApiError::{coder.error_variant | unescaped}(e)\n        }\n    }\n    {{- endfor }}\n}\n"</span>;

    <span class="kw">pub const </span>CLAP_YAML: <span class="kw-2">&amp;</span>str = <span class="string">"\nname: { name | unescaped }\nversion: { version | unescaped }\n\nsettings:\n- SubcommandRequiredElseHelp\n\nargs:\n    - ca-cert:\n        long: ca-cert\n        help: Path to CA certificate to be added to trust store.\n        takes_value: true\n    - client-cert:\n        long: client-cert\n        help: Path to certificate for TLS client verification.\n        takes_value: true\n        requires:\n            - client-key\n    - client-key:\n        long: client-key\n        help: Path to private key for TLS client verification.\n        takes_value: true\n        requires:\n            - client-cert\n    - url:\n        long: url\n        help: Base URL for your API.\n        takes_value: true\n        required: true\n    - verbose:\n        short: v\n        long: verbose\n        help: Enable verbose mode.\n    - timeout:\n        short: t\n        long: timeout\n        help: Set the request timeout.\n        takes_value: true\n\nsubcommands:\n"</span>;

    <span class="kw">pub const </span>CLI_MAIN: <span class="kw-2">&amp;</span>str = <span class="string">"\nuse self::client::\\{ApiClient, ApiError, Response};\nuse self::util::ResponseStream;\nuse anyhow::Error;\nuse clap::\\{App, ArgMatches};\nuse openssl::pkcs12::Pkcs12;\nuse openssl::pkey::PKey;\nuse openssl::x509::X509;\n\nuse std::fs::File;\nuse std::io::Read;\nuse std::path::Path;\n\n#[derive(Debug, thiserror::Error)]\n#[allow(dead_code)]\nenum ClientError \\{\n    #[error(\"Duration parse error: \\{}\", _0)]\n    Duration(humantime::DurationError),\n    #[error(\"I/O error: \\{}\", _0)]\n    Io(std::io::Error),\n    #[error(\"OpenSSL error: \\{}\", _0)]\n    OpenSsl(openssl::error::ErrorStack),\n    #[error(\"Client error: \\{}\", _0)]\n    Reqwest(reqwest::Error),\n    #[error(\"URL error: \\{}\", _0)]\n    Url(url::ParseError),\n    #[error(\"\\{}\", _0)]\n    Api(self::client::ApiError&lt;reqwest::Response&gt;),\n    #[error(\"\")]\n    Empty,\n}\n\nimpl From&lt;ApiError&lt;reqwest::Response&gt;&gt; for ClientError \\{\n    fn from(e: ApiError&lt;reqwest::Response&gt;) -&gt; Self \\{\n        ClientError::Api(e)\n    }\n}\n\nfn read_file&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; \\{\n    let mut data = vec![];\n    let mut fd = File::open(path.as_ref()).map_err(ClientError::Io)?;\n    fd.read_to_end(&amp;mut data).map_err(ClientError::Io)?;\n    Ok(data)\n}\n\n#[derive(Clone)]\nstruct WrappedClient \\{\n    verbose: bool,\n    inner: reqwest::Client,\n    url: reqwest::Url,\n}\n\n#[async_trait::async_trait]\nimpl ApiClient for WrappedClient \\{\n    type Request = reqwest::RequestBuilder;\n    type Response = reqwest::Response;\n\n    async fn make_request(&amp;self, req: Self::Request) -&gt; Result&lt;Self::Response, ApiError&lt;Self::Response&gt;&gt; \\{\n        let req = req.build().map_err(ApiError::Reqwest)?;\n        if self.verbose \\{\n            println!(\"\\{} \\{}\", req.method(), req.url());\n        }\n\n        Ok(self.inner.execute(req).await.map_err(ApiError::Reqwest)?)\n    }\n\n    fn request_builder(&amp;self, method: http::Method, rel_path: &amp;str) -&gt; Self::Request \\{\n        let mut u = self.url.clone();\n        let mut path = u.path().trim_matches('/').to_owned();\n        if !path.is_empty() \\{\n            path = String::from(\"/\") + &amp;path;\n        }\n\n        path.push_str(rel_path);\n        u.set_path(&amp;path);\n        self.inner.request(method, u)\n    }\n}\n\nfn make_client&lt;'a&gt;(matches: &amp;'a ArgMatches&lt;'a&gt;) -&gt; Result&lt;WrappedClient, Error&gt; \\{\n    let mut client = reqwest::Client::builder();\n\n    if let Some(p) = matches.value_of(\"ca-cert\") \\{\n        let ca_cert = X509::from_pem(&amp;read_file(p)?)\n            .map_err(ClientError::OpenSsl)?;\n        let ca_der = ca_cert.to_der().map_err(ClientError::OpenSsl)?;\n        client = client.add_root_certificate(\n            reqwest::Certificate::from_der(&amp;ca_der)\n                .map_err(ClientError::Reqwest)?\n        );\n    }\n\n    // FIXME: Is this the only way?\n    if let (Some(p1), Some(p2)) = (matches.value_of(\"client-key\"), matches.value_of(\"client-cert\")) \\{\n        let cert = X509::from_pem(&amp;read_file(p2)?).map_err(ClientError::OpenSsl)?;\n        let key = PKey::private_key_from_pem(&amp;read_file(p1)?)\n            .map_err(ClientError::OpenSsl)?;\n        let builder = Pkcs12::builder();\n        let pkcs12 = builder.build(\"foobar\", \"my-client\", &amp;key, &amp;cert)\n            .map_err(ClientError::OpenSsl)?;\n        let identity = reqwest::Identity::from_pkcs12_der(\n            &amp;pkcs12.to_der().map_err(ClientError::OpenSsl)?,\n            \"foobar\"\n        ).map_err(ClientError::Reqwest)?;\n        client = client.identity(identity);\n    }\n\n    if let Some(timeout) = matches.value_of(\"timeout\") \\{\n        let d = timeout.parse::&lt;humantime::Duration&gt;()?;\n        client = client.timeout(d.into());\n    }\n\n    let is_verbose = matches.is_present(\"verbose\");\n    let url = matches.value_of(\"url\").expect(\"required arg URL?\");\n    Ok(WrappedClient \\{\n        inner: client.build().map_err(ClientError::Reqwest)?,\n        url: reqwest::Url::parse(url).map_err(ClientError::Url)?,\n        verbose: is_verbose,\n    })\n}\n\nasync fn run_app() -&gt; Result&lt;(), Error&gt; \\{\n    let yml = load_yaml!(\"app.yaml\");\n    let app = App::from_yaml(yml);\n    let matches = app.get_matches();\n    let (sub_cmd, sub_matches) = matches.subcommand();\n\n    let client = make_client(&amp;matches)?;\n    let response = self::cli::fetch_response(&amp;client, &amp;matches, sub_cmd, sub_matches).await?;\n\n    let status = response.status();\n    if client.verbose \\{\n        println!(\"\\{}\", status);\n    }\n\n    let mut stdout = tokio::io::stdout();\n    ResponseStream(response.stream()).to_writer(&amp;mut stdout).await?;\n    if !status.is_success() \\{\n        Err(ClientError::Empty)?\n    }\n\n    Ok(())\n}\n\n#[tokio::main]\nasync fn main() \\{\n    env_logger::init();\n    if let Err(e) = run_app().await \\{\n        println!(\"\\{}\", e);\n    }\n}\n"</span>;

    <span class="kw">pub const </span>UTIL_MOD: <span class="kw-2">&amp;</span>str = <span class="string">"\nuse futures::stream::\\{Stream, StreamExt};\nuse serde::\\{Deserialize, Deserializer};\nuse tokio::io::\\{AsyncWrite, AsyncWriteExt};\n\nuse std::error::Error;\nuse std::fmt::\\{self, Display, Write};\nuse std::io;\nuse std::marker::\\{PhantomData, Unpin};\nuse std::ops::\\{Deref, DerefMut};\nuse std::str::FromStr;\n\n/// HTTP body response stream.\npub struct ResponseStream&lt;T, E&gt;(pub Box&lt;dyn Stream&lt;Item=Result&lt;T, E&gt;&gt; + Unpin&gt;);\n\n/// **NOTE:** This is just a stub. It panics on deserialization.\nimpl&lt;'de, T, E&gt; Deserialize&lt;'de&gt; for ResponseStream&lt;T, E&gt; \\{\n    fn deserialize&lt;D&gt;(_: D) -&gt; Result&lt;Self, D::Error&gt;\n    where\n        D: Deserializer&lt;'de&gt;\n    \\{\n        unimplemented!(\"Response stream is not supposed to be deserialized\");\n    }\n}\n\nimpl&lt;T, E&gt; ResponseStream&lt;T, E&gt;\n    where T: AsRef&lt;[u8]&gt;,\n          E: Into&lt;Box&lt;dyn Error + Send + Sync + 'static&gt;&gt;\n\\{\n    /// Copy this stream to anything that implements `AsyncWrite`.\n    pub async fn to_writer&lt;W&gt;(mut self, writer: &amp;mut W) -&gt; io::Result&lt;()&gt;\n        where W: AsyncWrite + Unpin + ?Sized\n    \\{\n        while let Some(r) = self.0.next().await \\{\n            let chunk = r.map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;\n            writer.write_all(chunk.as_ref()).await?;\n        }\n\n        Ok(())\n    }\n}\n\n/// Marker trait for delimiting. We represent each type of delimiting\n/// with an unit struct and implement this\npub trait Delimiting \\{\n    const DELIMITER: char;\n}\n\n/// Marker trait for whether the delimiting unit struct can be used by\n/// iterators. This is not implemented by `multi` - Multiple instances are\n/// allowed only in form data and query, and we need something for parsing\n/// stuff from CLI. At the same time, we also cannot allow serializing this\n/// container in the same way as others.\npub trait Allowed \\{}\n\nmacro_rules! impl_delim \\{\n    ($ty:ident =&gt; $delim:expr) =&gt; \\{\n        #[derive(Debug, Clone)]\n        pub struct $ty;\n\n        impl Delimiting for $ty \\{\n            const DELIMITER: char = $delim;\n        }\n    };\n}\n\nimpl_delim!(Csv =&gt; ',');\nimpl Allowed for Csv \\{}\n\nimpl_delim!(Ssv =&gt; ' ');\nimpl Allowed for Ssv \\{}\n\nimpl_delim!(Tsv =&gt; '\\t');\nimpl Allowed for Tsv \\{}\n\nimpl_delim!(Pipes =&gt; '|');\nimpl Allowed for Pipes \\{}\n\n// NOTE: We use ampersand only for convenience.\nimpl_delim!(Multi =&gt; '&amp;');\n\n/// Wrapper over a vector which also holds a marker type for delimiting.\n#[derive(Debug, Clone)]\npub struct Delimited&lt;T, D&gt;(Vec&lt;T&gt;, PhantomData&lt;D&gt;);\n\nimpl&lt;T, D&gt; From&lt;Vec&lt;T&gt;&gt; for Delimited&lt;T, D&gt; \\{\n    fn from(v: Vec&lt;T&gt;) -&gt; Self \\{\n        Delimited(v, PhantomData)\n    }\n}\n\nimpl&lt;T, D&gt; Deref for Delimited&lt;T, D&gt; \\{\n    type Target = Vec&lt;T&gt;;\n\n    fn deref(&amp;self) -&gt; &amp;Self::Target \\{\n        &amp;self.0\n    }\n}\n\nimpl&lt;T, D&gt; DerefMut for Delimited&lt;T, D&gt; \\{\n    fn deref_mut(&amp;mut self) -&gt; &amp;mut &lt;Self as Deref&gt;::Target \\{\n        &amp;mut self.0\n    }\n}\n\nimpl&lt;T: FromStr, D: Delimiting&gt; FromStr for Delimited&lt;T, D&gt; \\{\n    type Err = &lt;T as FromStr&gt;::Err;\n\n    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; \\{\n        let vec: Result&lt;Vec&lt;_&gt;, _&gt; = s.split(D::DELIMITER).map(|s| s.parse::&lt;T&gt;()).collect();\n        Ok(Delimited(vec?, PhantomData))\n    }\n}\n\nimpl&lt;T: Display, D: Delimiting + Allowed&gt; Display for Delimited&lt;T, D&gt; \\{\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result \\{\n        for (i, v) in self.0.iter().enumerate() \\{\n            if i &gt; 0 \\{\n                f.write_char(D::DELIMITER)?;\n            }\n\n            v.fmt(f)?;\n        }\n\n        Ok(())\n    }\n}\n"</span>;

    <span class="kw">pub const </span>CLI_UTIL: <span class="kw-2">&amp;</span>str = <span class="string">"use clap::ArgMatches;\nuse crate::client::\\{ApiClient, ApiError, Sendable};\nuse serde::\\{Serialize, Deserialize};\n\nuse std::io::Read;\n\npub(crate) fn read_from_input&lt;T&gt;(matches: Option&lt;&amp;ArgMatches&lt;'_&gt;&gt;) -&gt; Result&lt;T, crate::ClientError&gt;\nwhere\n    T: Serialize,\n    for&lt;'de&gt; T: Deserialize&lt;'de&gt;\n\\{\n    let path = matches\n        .expect(\"no args for builder with body?\")\n        .value_of(\"payload\").expect(\"payload?\");\n\n    let mut bytes = vec![];\n    if path == \"-\" \\{\n        std::io::stdin().read_to_end(&amp;mut bytes).map_err(crate::ClientError::Io)?;\n    } else \\{\n        std::fs::File::open(&amp;path)\n            .and_then(|mut fd| fd.read_to_end(&amp;mut bytes))\n            .map_err(crate::ClientError::Io)?;\n    };\n\n    {{- for coder in media_coders }}\n\n    let err = match {coder.decoder | unescaped}(bytes.as_slice()) \\{\n        Ok(t) =&gt; return Ok(t),\n        Err(e) =&gt; crate::ClientError::Api(ApiError::{coder.error_variant | unescaped}(e)),\n    };\n\n    log::debug!(\"Error decoding payload as {coder.range | unescaped}: \\{:?}\", err);\n    {{- endfor }}\n\n    Err(err)\n}\n\npub(super) async fn fetch_response&lt;'a, C&gt;(client: &amp;'a C,\n                                          _matches: &amp;ArgMatches&lt;'_&gt;,\n                                          sub_cmd: &amp;str,\n                                          sub_matches: Option&lt;&amp;ArgMatches&lt;'_&gt;&gt;)\n                                          -&gt; Result&lt;C::Response, crate::ClientError&gt;\nwhere\n    C: ApiClient + Send + Sync + 'static,\n    crate::ClientError: From&lt;ApiError&lt;C::Response&gt;&gt;\n\\{\n    let resp = match sub_cmd \\{\n{match_arms | unescaped}\n        _ =&gt; unimplemented!(),\n    };\n\n    match resp \\{\n        Ok(r) =&gt; Ok(r),\n        Err(ApiError::Failure(_, _, r)) =&gt; Ok(r.into_inner()),\n        Err(e) =&gt; return Err(e.into()),\n    }\n}\n"</span>;

    <span class="kw">pub fn </span>render&lt;C&gt;(t: Template, context: <span class="kw-2">&amp;</span>C) -&gt; tinytemplate::error::Result&lt;String&gt;
        <span class="kw">where </span>C: serde::Serialize
    {
        <span class="kw">let </span><span class="kw-2">mut </span>temp = TinyTemplate::new();
        temp.add_template(<span class="string">"file"</span>, <span class="kw">match </span>t {
            Template::CARGO_MANIFEST =&gt; CARGO_MANIFEST,
            Template::CLIENT_MOD =&gt; CLIENT_MOD,
            Template::CLAP_YAML =&gt; CLAP_YAML,
            Template::CLI_MAIN =&gt; CLI_MAIN,
            Template::UTIL_MOD =&gt; UTIL_MOD,
            Template::CLI_UTIL =&gt; CLI_UTIL,
        })<span class="question-mark">?</span>;

        temp.render(<span class="string">"file"</span>, context)
    }
}
</code></pre></div></section></main></body></html>