<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/travis/build/wafflespeanut/paperclip/target/debug/build/paperclip-74bea21b2a18640b/out/template.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>template.rs - source</title><link rel="stylesheet" type="text/css" href="../../../../../../../../../../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../../../../../../../../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../../../../../../../../../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../../../../../../../../../../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../../../../../../../../../../../ayu.css" disabled ><script id="default-settings"></script><script src="../../../../../../../../../../../../storage.js"></script><script src="../../../../../../../../../../../../crates.js"></script><noscript><link rel="stylesheet" href="../../../../../../../../../../../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../../../../../../../../../../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../../../../../../../../../../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../../../../../../../../../../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../../../../../../../../../../../down-arrow.svg");}</style></head><body class="rustdoc source"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../../../../../../../../../../../paperclip/index.html'><div class='logo-container rust-logo'><img src='../../../../../../../../../../../../rust-logo.png' alt='logo'></div></a></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../../../../../../../../../../../../brush.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../../../../../../../../../../../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../../../../../../../../../../../../settings.html"><img src="../../../../../../../../../../../../wheel.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><pre class="line-numbers"><span id="1"> 1</span>
<span id="2"> 2</span>
<span id="3"> 3</span>
<span id="4"> 4</span>
<span id="5"> 5</span>
<span id="6"> 6</span>
<span id="7"> 7</span>
<span id="8"> 8</span>
<span id="9"> 9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
</pre><div class="example-wrap"><pre class="rust ">

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;codegen&quot;</span>)]</span>
<span class="kw">mod</span> <span class="ident">template</span> {
    <span class="kw">use</span> <span class="ident">tinytemplate</span>::<span class="ident">TinyTemplate</span>;

    <span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">Copy</span>, <span class="ident">Clone</span>)]</span>
    <span class="attribute">#[<span class="ident">allow</span>(<span class="ident">dead_code</span>, <span class="ident">non_camel_case_types</span>)]</span>
    <span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">TEMPLATE</span> {
        <span class="ident">CARGO_MANIFEST</span>,
        <span class="ident">CLIENT_MOD</span>,
        <span class="ident">CLAP_YAML</span>,
        <span class="ident">CLI_MAIN</span>,
        <span class="ident">UTIL_MOD</span>,
        <span class="ident">CLI_UTIL</span>,
    }
    <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">CARGO_MANIFEST</span>: <span class="kw-2">&amp;</span><span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;[package]\nname = { name | unescaped }\nversion = { version | unescaped }\nauthors = { authors | unescaped }\nedition = \&quot;2018\&quot;\n{{ if is_cli }}\n[[bin]]\nname = { name | unescaped }\npath = \&quot;main.rs\&quot;\n{{ else }}\n[lib]\npath = \&quot;lib.rs\&quot;\n{{ endif }}\n[dependencies]\nasync-trait = \&quot;0.1\&quot;\nbytes = \&quot;0.5\&quot;\nthiserror = \&quot;1.0\&quot;\nfutures = \&quot;0.3\&quot;\nhttp = \&quot;0.2\&quot;\nlazy_static = \&quot;1.4\&quot;\nlog = \&quot;0.4\&quot;\nmime = \\{ git = \&quot;https://github.com/hyperium/mime\&quot; }\nmime_guess = \&quot;2.0\&quot;\nparking_lot = \&quot;0.11\&quot;\nserde = \\{ version = \&quot;1.0\&quot;, features = [\&quot;derive\&quot;] }\nserde_json = \&quot;1.0\&quot;\nserde_yaml = \&quot;0.8\&quot;\ntokio-util = \\{ version = \&quot;0.4\&quot;, features = [\&quot;codec\&quot;] }\nurl = \&quot;2.1\&quot;\n{{ if is_cli }}\nanyhow = \&quot;1.0\&quot;\nclap = \\{ version = \&quot;2.33\&quot;, features = [\&quot;yaml\&quot;] }\nenv_logger = \&quot;0.7\&quot;\nhumantime = \&quot;2.0\&quot;\nopenssl = \\{ version = \&quot;0.10\&quot;, features = [\&quot;vendored\&quot;] }\ntokio = \\{ version = \&quot;0.3\&quot;, features = [\&quot;fs\&quot;, \&quot;io-util\&quot;, \&quot;io-std\&quot;, \&quot;macros\&quot;, \&quot;rt-multi-thread\&quot;] }\nreqwest = \\{ version = \&quot;0.10\&quot;, features = [\&quot;stream\&quot;, \&quot;json\&quot;, \&quot;native-tls\&quot;] }\n{{ else }}\ntokio = \\{ version = \&quot;0.3\&quot;, features = [\&quot;fs\&quot;, \&quot;io-util\&quot;] }\nreqwest = \\{ version = \&quot;0.10\&quot;, features = [\&quot;stream\&quot;, \&quot;json\&quot;] }\n{{ endif }}\n{{ if not no_root -}}\n[workspace]\n{{- endif }}\n&quot;</span>;

    <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">CLIENT_MOD</span>: <span class="kw-2">&amp;</span><span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;\npub mod client \\{\n    use futures::Stream;\n    use parking_lot::Mutex;\n\n    use std::borrow::Cow;\n    use std::fmt::Debug;\n    use std::path::Path;\n\n    /// Common API errors.\n    #[derive(Debug, thiserror::Error)]\n    pub enum ApiError&lt;R: Debug + Send + \&#39;static&gt; \\{\n        #[error(\&quot;API request failed for path: \\{} (code: \\{})\&quot;, _0, _1)]\n        Failure(String, http::status::StatusCode, Mutex&lt;R&gt;),\n        #[error(\&quot;Unsupported media type in response: \\{}\&quot;, _0)]\n        UnsupportedMediaType(String, Mutex&lt;R&gt;),\n        #[error(\&quot;An error has occurred while performing the API request: \\{}\&quot;, _0)]\n        Reqwest(reqwest::Error),\n        #[error(\&quot;I/O error: \\{}\&quot;, _0)]\n        Io(std::io::Error),\n        {{- for coder in media_coders }}\n        #[error(\&quot;Error en/decoding \\\&quot;{coder.range | unescaped}\\\&quot; data: \\{}\&quot;, _0)]\n        {coder.error_variant | unescaped}({coder.error_ty_path | unescaped}),\n        {{- endfor }}\n    }\n\n    /// Form object for building multipart request body.\n    pub trait Form: Sized \\{\n        /// Creates a new builder.\n        fn new() -&gt; Self;\n\n        /// Adds the given key and value as text.\n        fn text&lt;T, U&gt;(self, key: T, value: U) -&gt; Self\n            where T: Into&lt;Cow&lt;\&#39;static, str&gt;&gt;,\n                  U: Into&lt;Cow&lt;\&#39;static, str&gt;&gt;;\n\n        /// Adds the file from the given path for streaming.\n        fn file&lt;K&gt;(self, key: K, path: &amp;Path) -&gt; std::io::Result&lt;Self&gt;\n            where K: Into&lt;Cow&lt;\&#39;static, str&gt;&gt;;\n    }\n\n    /// HTTP Request.\n    pub trait Request \\{\n        type Form: Form;\n\n        /// Sets the header with the given key and value.\n        fn header(self, name: &amp;\&#39;static str, value: &amp;str) -&gt; Self;\n\n        /// Sets body using the given vector of bytes.\n        ///\n        /// **NOTE:** Appropriate `Content-Type` header must be set\n        /// after calling this method.\n        fn body_bytes(self, body: Vec&lt;u8&gt;) -&gt; Self;\n\n        /// Sets JSON body based on the given value.\n        fn json&lt;T: serde::Serialize&gt;(self, value: &amp;T) -&gt; Self;\n\n        /// Sets `multipart/form-data` body using the given form.\n        fn multipart_form_data(self, form: Self::Form) -&gt; Self;\n\n        /// Sets/adds query parameters based on the given value.\n        ///\n        /// **NOTE:** This method must be called only once. It\&#39;s unspecified\n        /// as to whether this appends/replaces query parameters.\n        fn query&lt;T: serde::Serialize&gt;(self, params: &amp;T) -&gt; Self;\n    }\n\n    impl Form for reqwest::multipart::Form \\{\n        fn new() -&gt; Self \\{\n            reqwest::multipart::Form::new()\n        }\n\n        fn text&lt;T, U&gt;(self, key: T, value: U) -&gt; Self\n            where T: Into&lt;Cow&lt;\&#39;static, str&gt;&gt;,\n                  U: Into&lt;Cow&lt;\&#39;static, str&gt;&gt;\n        \\{\n            reqwest::multipart::Form::text(self, key, value)\n        }\n\n        fn file&lt;K&gt;(self, key: K, path: &amp;Path) -&gt; std::io::Result&lt;Self&gt;\n            where K: Into&lt;Cow&lt;\&#39;static, str&gt;&gt;\n        \\{\n            use reqwest::multipart::\\{Form, Part};\n            use tokio_util::codec::\\{BytesCodec, FramedRead};\n\n            let fd = std::fs::File::open(path)?;\n            let reader = tokio::fs::File::from_std(fd);\n            let bytes_stream = FramedRead::new(reader, BytesCodec::new());\n            let part = Part::stream(reqwest::Body::wrap_stream(bytes_stream));\n            Ok(Form::part(self, key, part))\n        }\n    }\n\n    impl Request for reqwest::RequestBuilder \\{\n        type Form = reqwest::multipart::Form;\n\n        fn header(self, name: &amp;\&#39;static str, value: &amp;str) -&gt; Self \\{\n            reqwest::RequestBuilder::header(self, name, value)\n        }\n\n        fn multipart_form_data(self, form: Self::Form) -&gt; Self \\{\n            self.multipart(form)\n        }\n\n        fn body_bytes(self, body: Vec&lt;u8&gt;) -&gt; Self \\{\n            self.body(body)\n        }\n\n        fn json&lt;T: serde::Serialize&gt;(self, value: &amp;T) -&gt; Self \\{\n            &lt;reqwest::RequestBuilder&gt;::json(self, value)\n        }\n\n        fn query&lt;T: serde::Serialize&gt;(self, params: &amp;T) -&gt; Self \\{\n            reqwest::RequestBuilder::query(self, params)\n        }\n    }\n\n    /// HTTP Response.\n    #[async_trait::async_trait]\n    pub trait Response: Debug + Send + Sized \\{\n        type Bytes: AsRef&lt;[u8]&gt;;\n        type Error;\n\n        /// Gets the value for the given header name, if any.\n        fn header(&amp;self, name: &amp;\&#39;static str) -&gt; Option&lt;&amp;str&gt;;\n\n        /// Takes all headers from the response.\n        fn take_headers(&amp;mut self) -&gt; http::header::HeaderMap;\n\n        /// Status code for this response.\n        fn status(&amp;self) -&gt; http::status::StatusCode;\n\n        /// Media type for this response body (if any).\n        fn media_type(&amp;self) -&gt; Option&lt;mime::MediaType&gt;;\n\n        /// Response body as a stream.\n        fn stream(self) -&gt; Box&lt;dyn Stream&lt;Item=Result&lt;Self::Bytes, Self::Error&gt;&gt; + Unpin&gt;;\n\n        /// Vector of bytes from the response body.\n        async fn body_bytes(self) -&gt; Result&lt;Self::Bytes, ApiError&lt;Self&gt;&gt;;\n    }\n\n    #[async_trait::async_trait]\n    impl Response for reqwest::Response \\{\n        type Bytes = bytes::Bytes;\n        type Error = reqwest::Error;\n\n        fn header(&amp;self, name: &amp;\&#39;static str) -&gt; Option&lt;&amp;str&gt; \\{\n            self.headers().get(name).and_then(|v| v.to_str().ok())\n        }\n\n        fn take_headers(&amp;mut self) -&gt; http::header::HeaderMap \\{\n            std::mem::replace(self.headers_mut(), http::header::HeaderMap::new())\n        }\n\n        fn status(&amp;self) -&gt; http::status::StatusCode \\{\n            reqwest::Response::status(self)\n        }\n\n        fn media_type(&amp;self) -&gt; Option&lt;mime::MediaType&gt; \\{\n            self.header(http::header::CONTENT_TYPE.as_str())\n                .and_then(|v| v.parse().ok())\n        }\n\n        fn stream(self) -&gt; Box&lt;dyn Stream&lt;Item=Result&lt;Self::Bytes, Self::Error&gt;&gt; + Unpin&gt; \\{\n            Box::new(self.bytes_stream()) as Box&lt;_&gt;\n        }\n\n        async fn body_bytes(self) -&gt; Result&lt;Self::Bytes, ApiError&lt;Self&gt;&gt; \\{\n            Ok(self.bytes().await.map_err(ApiError::Reqwest)?)\n        }\n    }\n\n    /// Represents an API client.\n    #[async_trait::async_trait]\n    pub trait ApiClient \\{\n        type Request: Request + Send;\n        type Response: Response;\n\n        /// Consumes a method and a relative path and produces a request builder for a single API call.\n        fn request_builder(&amp;self, method: http::Method, rel_path: &amp;str) -&gt; Self::Request;\n\n        /// Performs the HTTP request using the given `Request` object\n        /// and returns a `Response` future.\n        async fn make_request(&amp;self, req: Self::Request) -&gt; Result&lt;Self::Response, ApiError&lt;Self::Response&gt;&gt;;\n    }\n\n    #[async_trait::async_trait]\n    impl ApiClient for reqwest::Client \\{\n        type Request = reqwest::RequestBuilder;\n        type Response = reqwest::Response;\n\n        fn request_builder(&amp;self, method: http::Method, rel_path: &amp;str) -&gt; Self::Request \\{\n            let mut u = String::from(\&quot;{base_url | unescaped}\&quot;);\n            u.push_str(rel_path.trim_start_matches(\&#39;/\&#39;));\n            self.request(method, &amp;u)\n        }\n\n        async fn make_request(&amp;self, req: Self::Request) -&gt; Result&lt;Self::Response, ApiError&lt;Self::Response&gt;&gt; \\{\n            let req = req.build().map_err(ApiError::Reqwest)?;\n            let resp = self.execute(req).await.map_err(ApiError::Reqwest)?;\n            Ok(resp)\n        }\n    }\n\n    /// A trait for indicating that the implementor can send an API call.\n    #[async_trait::async_trait]\n    pub trait Sendable&lt;Client&gt;\n    where\n        Client: ApiClient + Sync + \&#39;static,\n        Self: Sized\n    \\{\n        /// The output object from this API request.\n        type Output: serde::de::DeserializeOwned;\n\n        /// HTTP method used by this call.\n        const METHOD: http::Method;\n\n        /// Relative URL for this API call formatted appropriately with parameter values.\n        ///\n        /// **NOTE:** This URL **must** begin with `/`.\n        fn rel_path(&amp;self) -&gt; std::borrow::Cow&lt;\&#39;static, str&gt;;\n\n        /// Modifier for this object. Builders override this method if they\n        /// wish to add query parameters, set body, etc.\n        fn modify(&amp;self, req: Client::Request) -&gt; Result&lt;Client::Request, ApiError&lt;Client::Response&gt;&gt; \\{\n            Ok(req)\n        }\n\n        /// Sends the request and returns a future for the response object.\n        async fn send(&amp;self, client: &amp;Client) -&gt; Result&lt;ResponseWrapper&lt;Self::Output, Self&gt;, ApiError&lt;Client::Response&gt;&gt; \\{\n            let resp = self.send_raw(client).await?;\n            let media = resp.media_type();\n            if let Some(ty) = media \\{\n                if media_types::M_0.matches(&amp;ty) \\{\n                    return ResponseWrapper::wrap(resp, |r| async \\{\n                        let bytes = r.body_bytes().await?;\n                        serde_json::from_reader(bytes.as_ref()).map_err(ApiError::from)\n                    }).await\n                }\n                else if media_types::M_1.matches(&amp;ty) \\{\n                    return ResponseWrapper::wrap(resp, |r| async \\{\n                        let bytes = r.body_bytes().await?;\n                        serde_yaml::from_reader(bytes.as_ref()).map_err(ApiError::from)\n                    }).await\n                }\n            }\n\n            let ty = resp.header(http::header::CONTENT_TYPE.as_str())\n                .map(|v| String::from_utf8_lossy(v.as_bytes()).into_owned())\n                .unwrap_or_default();\n            Err(ApiError::UnsupportedMediaType(ty, Mutex::new(resp)))\n        }\n\n        /// Convenience method for returning a raw response after sending a request.\n        async fn send_raw(&amp;self, client: &amp;Client) -&gt; Result&lt;Client::Response, ApiError&lt;Client::Response&gt;&gt; \\{\n            let rel_path = self.rel_path();\n            let req = self.modify(client.request_builder(Self::METHOD, &amp;rel_path))?;\n            let resp = client.make_request(req).await?;\n            if resp.status().is_success() \\{\n                Ok(resp)\n            } else \\{\n                Err(ApiError::Failure(rel_path.into_owned(), resp.status(), Mutex::new(resp)))\n            }\n        }\n    }\n\n    /// Wrapper containing response-related information.\n    pub struct ResponseWrapper&lt;T, B&gt; \\{\n        /// Response object\n        pub object: T,\n        /// Response headers\n        pub headers: http::HeaderMap,\n        /// Response status code\n        pub status: http::status::StatusCode,\n        _builder: core::marker::PhantomData&lt;B&gt;,\n    }\n\n    impl&lt;T, B&gt; ResponseWrapper&lt;T, B&gt; \\{\n        pub(crate) async fn wrap&lt;F, R&gt;(mut resp: R, f: impl FnOnce(R) -&gt; F) -&gt; Result&lt;Self, ApiError&lt;R&gt;&gt;\n            where F: std::future::Future&lt;Output=Result&lt;T, ApiError&lt;R&gt;&gt;&gt;,\n                  R: Response + \&#39;static\n        \\{\n            let status = resp.status();\n            let headers = resp.take_headers();\n            Ok(ResponseWrapper \\{\n                object: f(resp).await?,\n                headers,\n                status,\n                _builder: core::marker::PhantomData,\n            })\n        }\n    }\n\n    impl&lt;\&#39;de, T, B&gt; serde::de::Deserialize&lt;\&#39;de&gt; for ResponseWrapper&lt;T, B&gt; \\{\n        fn deserialize&lt;D&gt;(_: D) -&gt; Result&lt;Self, D::Error&gt;\n        where\n            D: serde::de::Deserializer&lt;\&#39;de&gt;\n        \\{\n            unimplemented!(\&quot;ResponseWrapper is not supposed to be deserialized.\&quot;);\n        }\n    }\n\n    impl&lt;T, B&gt; std::ops::Deref for ResponseWrapper&lt;T, B&gt; \\{\n        type Target = T;\n\n        fn deref(&amp;self) -&gt; &amp;Self::Target \\{\n            &amp;self.object\n        }\n    }\n\n    impl&lt;T, B&gt; std::ops::DerefMut for ResponseWrapper&lt;T, B&gt; \\{\n        fn deref_mut(&amp;mut self) -&gt; &amp;mut &lt;Self as std::ops::Deref&gt;::Target \\{\n            &amp;mut self.object\n        }\n    }\n\n    pub mod media_types \\{\n        use lazy_static::lazy_static;\n\n        lazy_static! \\{\n            {{- for coder in media_coders }}\n            pub static ref M_{ @index }: mime::MediaRange =\n                mime::MediaRange::parse(\&quot;{coder.range | unescaped}\&quot;).expect(\&quot;cannot parse \\\&quot;{coder.range | unescaped}\\\&quot; as media range\&quot;);\n            {{- endfor }}\n        }\n    }\n\n    impl&lt;R: Response + \&#39;static&gt; From&lt;std::io::Error&gt; for ApiError&lt;R&gt; \\{\n        fn from(e: std::io::Error) -&gt; Self \\{\n            ApiError::Io(e)\n        }\n    }\n    {{- for coder in media_coders }}\n\n    impl&lt;R: Response + \&#39;static&gt; From&lt;{coder.error_ty_path | unescaped}&gt; for ApiError&lt;R&gt; \\{\n        fn from(e: {coder.error_ty_path | unescaped}) -&gt; Self \\{\n            ApiError::{coder.error_variant | unescaped}(e)\n        }\n    }\n    {{- endfor }}\n}\n&quot;</span>;

    <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">CLAP_YAML</span>: <span class="kw-2">&amp;</span><span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;\nname: { name | unescaped }\nversion: { version | unescaped }\n\nsettings:\n- SubcommandRequiredElseHelp\n\nargs:\n    - ca-cert:\n        long: ca-cert\n        help: Path to CA certificate to be added to trust store.\n        takes_value: true\n    - client-cert:\n        long: client-cert\n        help: Path to certificate for TLS client verification.\n        takes_value: true\n        requires:\n            - client-key\n    - client-key:\n        long: client-key\n        help: Path to private key for TLS client verification.\n        takes_value: true\n        requires:\n            - client-cert\n    - url:\n        long: url\n        help: Base URL for your API.\n        takes_value: true\n        required: true\n    - verbose:\n        short: v\n        long: verbose\n        help: Enable verbose mode.\n    - timeout:\n        short: t\n        long: timeout\n        help: Set the request timeout.\n        takes_value: true\n\nsubcommands:\n&quot;</span>;

    <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">CLI_MAIN</span>: <span class="kw-2">&amp;</span><span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;\nuse self::client::\\{ApiClient, ApiError, Response};\nuse self::util::ResponseStream;\nuse anyhow::Error;\nuse clap::\\{App, ArgMatches};\nuse openssl::pkcs12::Pkcs12;\nuse openssl::pkey::PKey;\nuse openssl::x509::X509;\n\nuse std::fs::File;\nuse std::io::Read;\nuse std::path::Path;\n\n#[derive(Debug, thiserror::Error)]\n#[allow(dead_code)]\nenum ClientError \\{\n    #[error(\&quot;Duration parse error: \\{}\&quot;, _0)]\n    Duration(humantime::DurationError),\n    #[error(\&quot;I/O error: \\{}\&quot;, _0)]\n    Io(std::io::Error),\n    #[error(\&quot;OpenSSL error: \\{}\&quot;, _0)]\n    OpenSsl(openssl::error::ErrorStack),\n    #[error(\&quot;Client error: \\{}\&quot;, _0)]\n    Reqwest(reqwest::Error),\n    #[error(\&quot;URL error: \\{}\&quot;, _0)]\n    Url(url::ParseError),\n    #[error(\&quot;\\{}\&quot;, _0)]\n    Api(self::client::ApiError&lt;reqwest::Response&gt;),\n    #[error(\&quot;\&quot;)]\n    Empty,\n}\n\nimpl From&lt;ApiError&lt;reqwest::Response&gt;&gt; for ClientError \\{\n    fn from(e: ApiError&lt;reqwest::Response&gt;) -&gt; Self \\{\n        ClientError::Api(e)\n    }\n}\n\nfn read_file&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; \\{\n    let mut data = vec![];\n    let mut fd = File::open(path.as_ref()).map_err(ClientError::Io)?;\n    fd.read_to_end(&amp;mut data).map_err(ClientError::Io)?;\n    Ok(data)\n}\n\n#[derive(Clone)]\nstruct WrappedClient \\{\n    verbose: bool,\n    inner: reqwest::Client,\n    url: reqwest::Url,\n}\n\n#[async_trait::async_trait]\nimpl ApiClient for WrappedClient \\{\n    type Request = reqwest::RequestBuilder;\n    type Response = reqwest::Response;\n\n    async fn make_request(&amp;self, req: Self::Request) -&gt; Result&lt;Self::Response, ApiError&lt;Self::Response&gt;&gt; \\{\n        let req = req.build().map_err(ApiError::Reqwest)?;\n        if self.verbose \\{\n            println!(\&quot;\\{} \\{}\&quot;, req.method(), req.url());\n        }\n\n        Ok(self.inner.execute(req).await.map_err(ApiError::Reqwest)?)\n    }\n\n    fn request_builder(&amp;self, method: http::Method, rel_path: &amp;str) -&gt; Self::Request \\{\n        let mut u = self.url.clone();\n        let mut path = u.path().trim_matches(\&#39;/\&#39;).to_owned();\n        if !path.is_empty() \\{\n            path = String::from(\&quot;/\&quot;) + &amp;path;\n        }\n\n        path.push_str(rel_path);\n        u.set_path(&amp;path);\n        self.inner.request(method, u)\n    }\n}\n\nfn make_client&lt;\&#39;a&gt;(matches: &amp;\&#39;a ArgMatches&lt;\&#39;a&gt;) -&gt; Result&lt;WrappedClient, Error&gt; \\{\n    let mut client = reqwest::Client::builder();\n\n    if let Some(p) = matches.value_of(\&quot;ca-cert\&quot;) \\{\n        let ca_cert = X509::from_pem(&amp;read_file(p)?)\n            .map_err(ClientError::OpenSsl)?;\n        let ca_der = ca_cert.to_der().map_err(ClientError::OpenSsl)?;\n        client = client.add_root_certificate(\n            reqwest::Certificate::from_der(&amp;ca_der)\n                .map_err(ClientError::Reqwest)?\n        );\n    }\n\n    // FIXME: Is this the only way?\n    if let (Some(p1), Some(p2)) = (matches.value_of(\&quot;client-key\&quot;), matches.value_of(\&quot;client-cert\&quot;)) \\{\n        let cert = X509::from_pem(&amp;read_file(p2)?).map_err(ClientError::OpenSsl)?;\n        let key = PKey::private_key_from_pem(&amp;read_file(p1)?)\n            .map_err(ClientError::OpenSsl)?;\n        let builder = Pkcs12::builder();\n        let pkcs12 = builder.build(\&quot;foobar\&quot;, \&quot;my-client\&quot;, &amp;key, &amp;cert)\n            .map_err(ClientError::OpenSsl)?;\n        let identity = reqwest::Identity::from_pkcs12_der(\n            &amp;pkcs12.to_der().map_err(ClientError::OpenSsl)?,\n            \&quot;foobar\&quot;\n        ).map_err(ClientError::Reqwest)?;\n        client = client.identity(identity);\n    }\n\n    if let Some(timeout) = matches.value_of(\&quot;timeout\&quot;) \\{\n        let d = timeout.parse::&lt;humantime::Duration&gt;()?;\n        client = client.timeout(d.into());\n    }\n\n    let is_verbose = matches.is_present(\&quot;verbose\&quot;);\n    let url = matches.value_of(\&quot;url\&quot;).expect(\&quot;required arg URL?\&quot;);\n    Ok(WrappedClient \\{\n        inner: client.build().map_err(ClientError::Reqwest)?,\n        url: reqwest::Url::parse(url).map_err(ClientError::Url)?,\n        verbose: is_verbose,\n    })\n}\n\nasync fn run_app() -&gt; Result&lt;(), Error&gt; \\{\n    let yml = load_yaml!(\&quot;app.yaml\&quot;);\n    let app = App::from_yaml(yml);\n    let matches = app.get_matches();\n    let (sub_cmd, sub_matches) = matches.subcommand();\n\n    let client = make_client(&amp;matches)?;\n    let response = self::cli::fetch_response(&amp;client, &amp;matches, sub_cmd, sub_matches).await?;\n\n    let status = response.status();\n    if client.verbose \\{\n        println!(\&quot;\\{}\&quot;, status);\n    }\n\n    let mut stdout = tokio::io::stdout();\n    ResponseStream(response.stream()).to_writer(&amp;mut stdout).await?;\n    if !status.is_success() \\{\n        Err(ClientError::Empty)?\n    }\n\n    Ok(())\n}\n\n#[tokio::main]\nasync fn main() \\{\n    env_logger::init();\n    if let Err(e) = run_app().await \\{\n        println!(\&quot;\\{}\&quot;, e);\n    }\n}\n&quot;</span>;

    <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">UTIL_MOD</span>: <span class="kw-2">&amp;</span><span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;\nuse futures::stream::\\{Stream, StreamExt};\nuse serde::\\{Deserialize, Deserializer};\nuse tokio::io::\\{AsyncWrite, AsyncWriteExt};\n\nuse std::error::Error;\nuse std::fmt::\\{self, Display, Write};\nuse std::io;\nuse std::marker::\\{PhantomData, Unpin};\nuse std::ops::\\{Deref, DerefMut};\nuse std::str::FromStr;\n\n/// HTTP body response stream.\npub struct ResponseStream&lt;T, E&gt;(pub Box&lt;dyn Stream&lt;Item=Result&lt;T, E&gt;&gt; + Unpin&gt;);\n\n/// **NOTE:** This is just a stub. It panics on deserialization.\nimpl&lt;\&#39;de, T, E&gt; Deserialize&lt;\&#39;de&gt; for ResponseStream&lt;T, E&gt; \\{\n    fn deserialize&lt;D&gt;(_: D) -&gt; Result&lt;Self, D::Error&gt;\n    where\n        D: Deserializer&lt;\&#39;de&gt;\n    \\{\n        unimplemented!(\&quot;Response stream is not supposed to be deserialized\&quot;);\n    }\n}\n\nimpl&lt;T, E&gt; ResponseStream&lt;T, E&gt;\n    where T: AsRef&lt;[u8]&gt;,\n          E: Into&lt;Box&lt;dyn Error + Send + Sync + \&#39;static&gt;&gt;\n\\{\n    /// Copy this stream to anything that implements `AsyncWrite`.\n    pub async fn to_writer&lt;W&gt;(mut self, writer: &amp;mut W) -&gt; io::Result&lt;()&gt;\n        where W: AsyncWrite + Unpin + ?Sized\n    \\{\n        while let Some(r) = self.0.next().await \\{\n            let chunk = r.map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;\n            writer.write(chunk.as_ref()).await?;\n        }\n\n        Ok(())\n    }\n}\n\n/// Marker trait for delimiting. We represent each type of delimiting\n/// with an unit struct and implement this\npub trait Delimiting \\{\n    const DELIMITER: char;\n}\n\n/// Marker trait for whether the delimiting unit struct can be used by\n/// iterators. This is not implemented by `multi` - Multiple instances are\n/// allowed only in form data and query, and we need something for parsing\n/// stuff from CLI. At the same time, we also cannot allow serializing this\n/// container in the same way as others.\npub trait Allowed \\{}\n\nmacro_rules! impl_delim \\{\n    ($ty:ident =&gt; $delim:expr) =&gt; \\{\n        #[derive(Debug, Clone)]\n        pub struct $ty;\n\n        impl Delimiting for $ty \\{\n            const DELIMITER: char = $delim;\n        }\n    };\n}\n\nimpl_delim!(Csv =&gt; \&#39;,\&#39;);\nimpl Allowed for Csv \\{}\n\nimpl_delim!(Ssv =&gt; \&#39; \&#39;);\nimpl Allowed for Ssv \\{}\n\nimpl_delim!(Tsv =&gt; \&#39;\\t\&#39;);\nimpl Allowed for Tsv \\{}\n\nimpl_delim!(Pipes =&gt; \&#39;|\&#39;);\nimpl Allowed for Pipes \\{}\n\n// NOTE: We use ampersand only for convenience.\nimpl_delim!(Multi =&gt; \&#39;&amp;\&#39;);\n\n/// Wrapper over a vector which also holds a marker type for delimiting.\n#[derive(Debug, Clone)]\npub struct Delimited&lt;T, D&gt;(Vec&lt;T&gt;, PhantomData&lt;D&gt;);\n\nimpl&lt;T, D&gt; From&lt;Vec&lt;T&gt;&gt; for Delimited&lt;T, D&gt; \\{\n    fn from(v: Vec&lt;T&gt;) -&gt; Self \\{\n        Delimited(v, PhantomData)\n    }\n}\n\nimpl&lt;T, D&gt; Deref for Delimited&lt;T, D&gt; \\{\n    type Target = Vec&lt;T&gt;;\n\n    fn deref(&amp;self) -&gt; &amp;Self::Target \\{\n        &amp;self.0\n    }\n}\n\nimpl&lt;T, D&gt; DerefMut for Delimited&lt;T, D&gt; \\{\n    fn deref_mut(&amp;mut self) -&gt; &amp;mut &lt;Self as Deref&gt;::Target \\{\n        &amp;mut self.0\n    }\n}\n\nimpl&lt;T: FromStr, D: Delimiting&gt; FromStr for Delimited&lt;T, D&gt; \\{\n    type Err = &lt;T as FromStr&gt;::Err;\n\n    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; \\{\n        let vec: Result&lt;Vec&lt;_&gt;, _&gt; = s.split(D::DELIMITER).map(|s| s.parse::&lt;T&gt;()).collect();\n        Ok(Delimited(vec?, PhantomData))\n    }\n}\n\nimpl&lt;T: Display, D: Delimiting + Allowed&gt; Display for Delimited&lt;T, D&gt; \\{\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result \\{\n        for (i, v) in self.0.iter().enumerate() \\{\n            if i &gt; 0 \\{\n                f.write_char(D::DELIMITER)?;\n            }\n\n            v.fmt(f)?;\n        }\n\n        Ok(())\n    }\n}\n&quot;</span>;

    <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">CLI_UTIL</span>: <span class="kw-2">&amp;</span><span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;use clap::ArgMatches;\nuse crate::client::\\{ApiClient, ApiError, Sendable};\nuse serde::\\{Serialize, Deserialize};\n\nuse std::io::Read;\n\npub(crate) fn read_from_input&lt;T&gt;(matches: Option&lt;&amp;ArgMatches&lt;\&#39;_&gt;&gt;) -&gt; Result&lt;T, crate::ClientError&gt;\nwhere\n    T: Serialize,\n    for&lt;\&#39;de&gt; T: Deserialize&lt;\&#39;de&gt;\n\\{\n    let path = matches\n        .expect(\&quot;no args for builder with body?\&quot;)\n        .value_of(\&quot;payload\&quot;).expect(\&quot;payload?\&quot;);\n\n    let mut bytes = vec![];\n    if path == \&quot;-\&quot; \\{\n        std::io::stdin().read_to_end(&amp;mut bytes).map_err(crate::ClientError::Io)?;\n    } else \\{\n        std::fs::File::open(&amp;path)\n            .and_then(|mut fd| fd.read_to_end(&amp;mut bytes))\n            .map_err(crate::ClientError::Io)?;\n    };\n\n    {{- for coder in media_coders }}\n\n    let err = match {coder.decoder | unescaped}(bytes.as_slice()) \\{\n        Ok(t) =&gt; return Ok(t),\n        Err(e) =&gt; crate::ClientError::Api(ApiError::{coder.error_variant | unescaped}(e)),\n    };\n\n    log::debug!(\&quot;Error decoding payload as {coder.range | unescaped}: \\{:?}\&quot;, err);\n    {{- endfor }}\n\n    Err(err)\n}\n\npub(super) async fn fetch_response&lt;\&#39;a, C&gt;(client: &amp;\&#39;a C,\n                                          _matches: &amp;ArgMatches&lt;\&#39;_&gt;,\n                                          sub_cmd: &amp;str,\n                                          sub_matches: Option&lt;&amp;ArgMatches&lt;\&#39;_&gt;&gt;)\n                                          -&gt; Result&lt;C::Response, crate::ClientError&gt;\nwhere\n    C: ApiClient + Send + Sync + \&#39;static,\n    crate::ClientError: From&lt;ApiError&lt;C::Response&gt;&gt;\n\\{\n    let resp = match sub_cmd \\{\n{match_arms | unescaped}\n        _ =&gt; unimplemented!(),\n    };\n\n    match resp \\{\n        Ok(r) =&gt; Ok(r),\n        Err(ApiError::Failure(_, _, r)) =&gt; Ok(r.into_inner()),\n        Err(e) =&gt; return Err(e.into()),\n    }\n}\n&quot;</span>;

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">render</span><span class="op">&lt;</span><span class="ident">C</span><span class="op">&gt;</span>(<span class="ident">t</span>: <span class="ident">TEMPLATE</span>, <span class="ident">context</span>: <span class="kw-2">&amp;</span><span class="ident">C</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">tinytemplate</span>::<span class="ident">error</span>::<span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>
        <span class="kw">where</span> <span class="ident">C</span>: <span class="ident">serde</span>::<span class="ident">Serialize</span>
    {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">temp</span> <span class="op">=</span> <span class="ident">TinyTemplate</span>::<span class="ident">new</span>();
        <span class="ident">temp</span>.<span class="ident">add_template</span>(<span class="string">&quot;file&quot;</span>, <span class="kw">match</span> <span class="ident">t</span> {
            <span class="ident">TEMPLATE</span>::<span class="ident">CARGO_MANIFEST</span> <span class="op">=</span><span class="op">&gt;</span> <span class="ident">CARGO_MANIFEST</span>,
            <span class="ident">TEMPLATE</span>::<span class="ident">CLIENT_MOD</span> <span class="op">=</span><span class="op">&gt;</span> <span class="ident">CLIENT_MOD</span>,
            <span class="ident">TEMPLATE</span>::<span class="ident">CLAP_YAML</span> <span class="op">=</span><span class="op">&gt;</span> <span class="ident">CLAP_YAML</span>,
            <span class="ident">TEMPLATE</span>::<span class="ident">CLI_MAIN</span> <span class="op">=</span><span class="op">&gt;</span> <span class="ident">CLI_MAIN</span>,
            <span class="ident">TEMPLATE</span>::<span class="ident">UTIL_MOD</span> <span class="op">=</span><span class="op">&gt;</span> <span class="ident">UTIL_MOD</span>,
            <span class="ident">TEMPLATE</span>::<span class="ident">CLI_UTIL</span> <span class="op">=</span><span class="op">&gt;</span> <span class="ident">CLI_UTIL</span>,
        })<span class="question-mark">?</span>;

        <span class="ident">temp</span>.<span class="ident">render</span>(<span class="string">&quot;file&quot;</span>, <span class="ident">context</span>)
    }
}
</pre></div>
</section><section id="search" class="content hidden"></section><section class="footer"></section><div id="rustdoc-vars" data-root-path="../../../../../../../../../../../../" data-current-crate="paperclip" data-search-js="../../../../../../../../../../../../search-index.js"></div>
    <script src="../../../../../../../../../../../../main.js"></script><script src="../../../../../../../../../../../../source-script.js"></script><script src="../../../../../../../../../../../../source-files.js"></script></body></html>