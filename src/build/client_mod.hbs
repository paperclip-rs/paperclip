
pub mod client \{
    use futures::Stream;


    use std::borrow::Cow;
    use std::fmt::Debug;
    use std::path::Path;

    /// Common API errors.
    #[derive(Debug, thiserror::Error)]
    pub enum ApiError<R: Debug + Send + 'static> \{
        #[error("API request failed for path: \{} (code: \{})", _0, _1)]
        Failure(String, http::status::StatusCode, R),
        #[error("Unsupported media type in response: \{}", _0)]
        UnsupportedMediaType(String, R),
        #[error("An error has occurred while performing the API request: \{}", _0)]
        Reqwest(reqwest::Error),
        #[error("I/O error: \{}", _0)]
        Io(std::io::Error),
        {{- for coder in media_coders }}
        #[error("Error en/decoding \"{coder.range | unescaped}\" data: \{}", _0)]
        {coder.error_variant | unescaped}({coder.error_ty_path | unescaped}),
        {{- endfor }}
    }

    /// Form object for building multipart request body.
    pub trait Form: Sized \{
        /// Creates a new builder.
        fn new() -> Self;

        /// Adds the given key and value as text.
        fn text<T, U>(self, key: T, value: U) -> Self
            where T: Into<Cow<'static, str>>,
                  U: Into<Cow<'static, str>>;

        /// Adds the file from the given path for streaming.
        fn file<K>(self, key: K, path: &Path) -> std::io::Result<Self>
            where K: Into<Cow<'static, str>>;
    }

    /// HTTP Request.
    pub trait Request \{
        type Form: Form;

        /// Sets the header with the given key and value.
        fn header(self, name: &'static str, value: &str) -> Self;

        /// Sets body using the given vector of bytes.
        ///
        /// **NOTE:** Appropriate `Content-Type` header must be set
        /// after calling this method.
        fn body_bytes(self, body: Vec<u8>) -> Self;

        /// Sets JSON body based on the given value.
        fn json<T: serde::Serialize>(self, value: &T) -> Self;

        /// Sets `multipart/form-data` body using the given form.
        fn multipart_form_data(self, form: Self::Form) -> Self;

        /// Sets/adds query parameters based on the given value.
        ///
        /// **NOTE:** This method must be called only once. It's unspecified
        /// as to whether this appends/replaces query parameters.
        fn query<T: serde::Serialize>(self, params: &T) -> Self;
    }

    impl Form for reqwest::multipart::Form \{
        fn new() -> Self \{
            reqwest::multipart::Form::new()
        }

        fn text<T, U>(self, key: T, value: U) -> Self
            where T: Into<Cow<'static, str>>,
                  U: Into<Cow<'static, str>>
        \{
            reqwest::multipart::Form::text(self, key, value)
        }

        fn file<K>(self, key: K, path: &Path) -> std::io::Result<Self>
            where K: Into<Cow<'static, str>>
        \{
            use reqwest::multipart::\{Form, Part};
            use tokio_util::codec::\{BytesCodec, FramedRead};

            let fd = std::fs::File::open(path)?;
            let reader = tokio::fs::File::from_std(fd);
            let bytes_stream = FramedRead::new(reader, BytesCodec::new());
            let part = Part::stream(reqwest::Body::wrap_stream(bytes_stream));
            Ok(Form::part(self, key, part))
        }
    }

    impl Request for reqwest::RequestBuilder \{
        type Form = reqwest::multipart::Form;

        fn header(self, name: &'static str, value: &str) -> Self \{
            reqwest::RequestBuilder::header(self, name, value)
        }

        fn multipart_form_data(self, form: Self::Form) -> Self \{
            self.multipart(form)
        }

        fn body_bytes(self, body: Vec<u8>) -> Self \{
            self.body(body)
        }

        fn json<T: serde::Serialize>(self, value: &T) -> Self \{
            <reqwest::RequestBuilder>::json(self, value)
        }

        fn query<T: serde::Serialize>(self, params: &T) -> Self \{
            reqwest::RequestBuilder::query(self, params)
        }
    }

    /// HTTP Response.
    #[async_trait::async_trait]
    pub trait Response: Debug + Send + Sized \{
        type Bytes: AsRef<[u8]>;
        type Error;

        /// Gets the value for the given header name, if any.
        fn header(&self, name: &'static str) -> Option<&str>;

        /// Takes all headers from the response.
        fn take_headers(&mut self) -> http::header::HeaderMap;

        /// Status code for this response.
        fn status(&self) -> http::status::StatusCode;

        /// Media type for this response body (if any).
        fn media_type(&self) -> Option<mime::MediaType>;

        /// Response body as a stream.
        fn stream(self) -> Box<dyn Stream<Item=Result<Self::Bytes, Self::Error>> + Unpin>;

        /// Vector of bytes from the response body.
        async fn body_bytes(self) -> Result<Self::Bytes, ApiError<Self>>;
    }

    #[async_trait::async_trait]
    impl Response for reqwest::Response \{
        type Bytes = bytes::Bytes;
        type Error = reqwest::Error;

        fn header(&self, name: &'static str) -> Option<&str> \{
            self.headers().get(name).and_then(|v| v.to_str().ok())
        }

        fn take_headers(&mut self) -> http::header::HeaderMap \{
            std::mem::replace(self.headers_mut(), http::header::HeaderMap::new())
        }

        fn status(&self) -> http::status::StatusCode \{
            reqwest::Response::status(self)
        }

        fn media_type(&self) -> Option<mime::MediaType> \{
            self.header(http::header::CONTENT_TYPE.as_str())
                .and_then(|v| v.parse().ok())
        }

        fn stream(self) -> Box<dyn Stream<Item=Result<Self::Bytes, Self::Error>> + Unpin> \{
            Box::new(self.bytes_stream()) as Box<_>
        }

        async fn body_bytes(self) -> Result<Self::Bytes, ApiError<Self>> \{
            Ok(self.bytes().await.map_err(ApiError::Reqwest)?)
        }
    }

    /// Represents an API client.
    #[async_trait::async_trait]
    pub trait ApiClient \{
        type Request: Request + Send;
        type Response: Response;

        /// Consumes a method and a relative path and produces a request builder for a single API call.
        fn request_builder(&self, method: http::Method, rel_path: &str) -> Self::Request;

        /// Performs the HTTP request using the given `Request` object
        /// and returns a `Response` future.
        async fn make_request(&self, req: Self::Request) -> Result<Self::Response, ApiError<Self::Response>>;
    }

    /// Defines api key that will be used for all requests.
    #[derive(Clone)]
    pub struct ApiKey \{
        /// Key will be sent in this HTTP header
        pub header_name: String,
        /// Key itself
        pub key: String,
    }

    #[derive(Clone)]
    pub struct ClientConfiguration \{
        base_url: String,
        api_key: Option<ApiKey>
    }

    impl ClientConfiguration \{
        pub fn new() -> ClientConfiguration \{
            ClientConfiguration \{
                base_url: String::from("{base_url | unescaped}"),
                api_key: None,
            }
        }

        pub fn set_base_url(&mut self, url: impl Into<String>) -> &mut Self \{
            self.base_url = url.into();
            self
        }

        pub fn set_api_key(&mut self, api_key: ApiKey) -> &mut Self \{
            self.api_key = Some(api_key);
            self
        }

        pub fn remove_api_key(&mut self) -> &mut Self \{
            self.api_key.take();
            self
        }
    }

    impl Default for ClientConfiguration \{
        fn default() -> ClientConfiguration \{
            ClientConfiguration::new()
        }
    }

    pub struct Client \{
        client: reqwest::Client,
        cfg: ClientConfiguration,
    }

    impl Client \{
        pub fn new(cfg: ClientConfiguration) -> Client \{
            Client \{
                client: reqwest::Client::new(),
                cfg
            }
        }

        /// Returns currently used configuration
        pub fn config(&self) -> &ClientConfiguration \{
            &self.cfg
        }

        /// Returns mutable reference to currently used configuration.
        /// If you modify it, all subsequent API requests will be affected.
        pub fn config_mut(&mut self) -> &mut ClientConfiguration \{
            &mut self.cfg
        }
    }

    impl Default for Client \{
        fn default() -> Client \{
            Client::new(ClientConfiguration::new())
        }
    }

    #[async_trait::async_trait]
    impl ApiClient for Client \{
        type Request = reqwest::RequestBuilder;
        type Response = reqwest::Response;

        fn request_builder(&self, method: http::Method, rel_path: &str) -> Self::Request \{
            let mut u = self.cfg.base_url.clone();
            u.push_str(rel_path.trim_start_matches('/'));
            let mut builder = self.client.request(method, &u);
            if let Some(key) = &self.cfg.api_key \{
                builder = builder.header(key.header_name.as_str(), key.key.as_str());
            }
            builder
        }

        async fn make_request(&self, req: Self::Request) -> Result<Self::Response, ApiError<Self::Response>> \{
            let req = req.build().map_err(ApiError::Reqwest)?;
            let resp = self.client.execute(req).await.map_err(ApiError::Reqwest)?;
            Ok(resp)
        }
    }

    /// A trait for indicating that the implementor can send an API call.
    #[async_trait::async_trait]
    pub trait Sendable<Client>
    where
        Client: ApiClient + Sync + 'static,
        Self: Sized
    \{
        /// The output object from this API request.
        type Output: serde::de::DeserializeOwned;

        /// HTTP method used by this call.
        const METHOD: http::Method;

        /// Relative URL for this API call formatted appropriately with parameter values.
        ///
        /// **NOTE:** This URL **must** begin with `/`.
        fn rel_path(&self) -> std::borrow::Cow<'static, str>;

        /// Modifier for this object. Builders override this method if they
        /// wish to add query parameters, set body, etc.
        fn modify(&self, req: Client::Request) -> Result<Client::Request, ApiError<Client::Response>> \{
            Ok(req)
        }

        /// Sends the request and returns a future for the response object.
        async fn send(&self, client: &Client) -> Result<ResponseWrapper<Self::Output, Self>, ApiError<Client::Response>> \{
            let resp = self.send_raw(client).await?;
            let media = resp.media_type();
            if let Some(ty) = media \{
                if media_types::M_0.matches(&ty) \{
                    return ResponseWrapper::wrap(resp, |r| async \{
                        let bytes = r.body_bytes().await?;
                        serde_json::from_reader(bytes.as_ref()).map_err(ApiError::from)
                    }).await
                }
                else if media_types::M_1.matches(&ty) \{
                    return ResponseWrapper::wrap(resp, |r| async \{
                        let bytes = r.body_bytes().await?;
                        serde_yaml::from_reader(bytes.as_ref()).map_err(ApiError::from)
                    }).await
                }
            }

            let ty = resp.header(http::header::CONTENT_TYPE.as_str())
                .map(|v| String::from_utf8_lossy(v.as_bytes()).into_owned())
                .unwrap_or_default();
            Err(ApiError::UnsupportedMediaType(ty, resp))
        }

        /// Convenience method for returning a raw response after sending a request.
        async fn send_raw(&self, client: &Client) -> Result<Client::Response, ApiError<Client::Response>> \{
            let rel_path = self.rel_path();
            let req = self.modify(client.request_builder(Self::METHOD, &rel_path))?;
            let resp = client.make_request(req).await?;
            if resp.status().is_success() \{
                Ok(resp)
            } else \{
                Err(ApiError::Failure(rel_path.into_owned(), resp.status(), resp))
            }
        }
    }

    /// Wrapper containing response-related information.
    pub struct ResponseWrapper<T, B> \{
        /// Response object
        pub object: T,
        /// Response headers
        pub headers: http::HeaderMap,
        /// Response status code
        pub status: http::status::StatusCode,
        _builder: core::marker::PhantomData<B>,
    }

    impl<T, B> ResponseWrapper<T, B> \{
        pub(crate) async fn wrap<F, R>(mut resp: R, f: impl FnOnce(R) -> F) -> Result<Self, ApiError<R>>
            where F: std::future::Future<Output=Result<T, ApiError<R>>>,
                  R: Response + 'static
        \{
            let status = resp.status();
            let headers = resp.take_headers();
            Ok(ResponseWrapper \{
                object: f(resp).await?,
                headers,
                status,
                _builder: core::marker::PhantomData,
            })
        }
    }

    impl<'de, T, B> serde::de::Deserialize<'de> for ResponseWrapper<T, B> \{
        fn deserialize<D>(_: D) -> Result<Self, D::Error>
        where
            D: serde::de::Deserializer<'de>
        \{
            unimplemented!("ResponseWrapper is not supposed to be deserialized.");
        }
    }

    impl<T, B> std::ops::Deref for ResponseWrapper<T, B> \{
        type Target = T;

        fn deref(&self) -> &Self::Target \{
            &self.object
        }
    }

    impl<T, B> std::ops::DerefMut for ResponseWrapper<T, B> \{
        fn deref_mut(&mut self) -> &mut <Self as std::ops::Deref>::Target \{
            &mut self.object
        }
    }

    pub mod media_types \{
        use lazy_static::lazy_static;

        lazy_static! \{
            {{- for coder in media_coders }}
            pub static ref M_{ @index }: mime::MediaRange =
                mime::MediaRange::parse("{coder.range | unescaped}").expect("cannot parse \"{coder.range | unescaped}\" as media range");
            {{- endfor }}
        }
    }

    impl<R: Response + 'static> From<std::io::Error> for ApiError<R> \{
        fn from(e: std::io::Error) -> Self \{
            ApiError::Io(e)
        }
    }
    {{- for coder in media_coders }}

    impl<R: Response + 'static> From<{coder.error_ty_path | unescaped}> for ApiError<R> \{
        fn from(e: {coder.error_ty_path | unescaped}) -> Self \{
            ApiError::{coder.error_variant | unescaped}(e)
        }
    }
    {{- endfor }}
}
